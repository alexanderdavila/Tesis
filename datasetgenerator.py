# -*- coding: utf-8 -*-
"""DatasetGenerator.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zJv4r1fZr5D5swT0K8GbfaIMDT04-UXE
"""

!pip install biopython

from google.colab import drive
drive.mount('/content/drive')

class ControlData:

  def __init__(self):
    self.decline=0.97
    self.entry=0.03
    self.count_zero=0
    self.conut_one=0
    '''Read protein sequence'''
    self.flag = [0,1]
    self.pro = [self.decline,self.entry]
  
  def update_percentages(self,decline,entry):
    self.decline=round(decline,3)
    self.entry=round(entry,3)
    self.peso = [self.decline,self.entry]

  def controlRecords(self,count_zero,conut_one):  
    if(count_zero>conut_one and (count_zero-conut_one)>50):
      self.update_percentages(self.decline+0.01,self.entry-0.01)
    else:
      if(conut_one>count_zero and (conut_one-count_zero)>50):        
        self.update_percentages(self.decline-0.02,self.entry+0.02)

class Protein:
  def __init__(self,name,sequence_original,modified_sequence):
    self.name=name
    self.sequence_original
    self.modified_sequence
    self.size
    self.ventana=[]
    self.combinations=[]
  
  def create_protein(self,url_file):
    '''Obtaining the sequence of a protein is specific'''
    self.sequence_original = get_sequence(url_file)
    self.size = len(sequence_original)

    '''Method that adds special character "-" at the beginning and at the end of the sequence. 
      The amount depends on the size of the window.
      Example: 
      if n is window size, n=19
      So we apply mod to get the number of characters to add 9=(n // 2) where it must be an odd number n=2a-1.'''        
    self.modified_sequence=prepareSequence(sequence)

class Windows:
  def __init__(self):
    self.aminoacids
    self.distance
    self.position
    self.encode
  
  def get_iterator_combinations(self,modified_sequence):    
    ventaneo=create_pairwise(modified_sequence)
    a=combinations(ventaneo,2)
    return a

  '''Create groups of n amino acids. for instance
   1 from i to n
   2 from i+1 to n+1.   
   '''
  def create_pairwise(iterable):
    l=[]
    l=tee(iterable,n)
    for i in range(1,n):
      for a in range(i):
        next(l[i],None)
    return zip(*l)

class Aminoacid:
  def __init__(self):  
    self.letter
    self.identify
    self.position

import itertools as it
import collections

def tee(iterable, n=2):
    it = iter(iterable)
    deques = [collections.deque() for i in range(n)]
    def gen(mydeque):    
        while True:            
            if not mydeque:             # when the local deque is empty
                try:
                    newval = next(it)   # fetch a new value and
                except StopIteration:
                    return
                for d in deques:        # load it to all the deques
                    d.append(newval)
            yield mydeque.popleft()
    
   
    return tuple(gen(d) for d in deques)
        
def create_pairwise(iterable):
    n=3
    l=[]
    l=it.tee(iterable,n)
    for i in range(1,n):      
       for a in range(i):
          next(l[i],None)         
    
    return zip(*l)

r=create_pairwise (['A','B','C','D','E'])

def main():
  proteins= Funtions()

if __name__ == '__main__':
    main()

# Commented out IPython magic to ensure Python compatibility.
from re import S, split
from Bio import SeqIO
from Bio.PDB import PDBList
import numpy as np
from collections import defaultdict
from itertools import *
from Bio.PDB.PDBParser import PDBParser
from Bio import *
import tensorflow as tf
import os
import random
import rpy2.robjects.numpy2ri as rpyn
import itertools as it

from Bio import motifs 
from Bio.Seq import Seq 

'''Global configuration variables'''
rechazo=0.97
ingreso=0.03
n=19
numAdd=(n // 2)

# %load_ext rpy2.ipython
# %R install.packages("Peptides", dependencies=TRUE)
# %R library(Peptides)

'''create dictionary'''
def create_dictionary(aminoacids):
    dictionary=defaultdict(lambda: 20,zip(aminoacids,[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))
    return dictionary

aminoacids="DERKNHQSTAGVPLFYIMWC-"
diccionario=create_dictionary(aminoacids)


'''get id's from pdb'''
def get_idProteins (file):
    fic = open(file, "r")
    lines = []
    for line in fic:
        lines.append(line)
    fic.close()
    PDBlist2=[]
    PDBlist2=lines[0].split(',')

    return PDBlist2

'''Selecting structures from PDB'''
def download_pdb(pdblist):
    pdbl = PDBList()

    for i in pdblist:
         pdbl.retrieve_pdb_file(i,pdir='/content/drive/MyDrive/Tesis/PDB',file_format="pdb") #-> str

'''Get sequence from pdb'''
def get_sequence(pdblist):
    for list in pdblist:
        PDBFile = "/content/drive/MyDrive/Tesis/PDB/pdb"+list+".ent"
        with open(PDBFile, 'r') as pdb_file:
            for record in SeqIO.parse(pdb_file, 'pdb-atom'):
                pdb_file.close()
                return record.seq


'''Create nxn matrix of zeros'''
def create matrix():
    array=np.zeros((21,21),dtype=float)
    return array


'''Traverse-sequence distance n'''
def recorrer_ventana(ventana,j,paso):
    var=ventana[j]

    tupla=[]
    for i in range(0,len(ventana)-paso):
        if ventana[i]==var:
            tupla.append(ventana[i])
            tupla.append(ventana[i+paso])
    return tupla

'''get coordinates'''
def get_encoding(tupla):
    item=[]
    for i in range(0,len(tupla)):
        for j in range(0,len(tupla[0])):
            item.append(diccionario[tupla[i][j]])

    return item
'''Validate if the amino acid has been evaluated'''
def element_exist(list,index):

    if list.count(list[index])>=2:
        flag=True
    else:
        flag=False
    return flag

'''Add special character to sequence'''
def prepareSequence(sequence):
    complemento=list("-"*numAdd)
    sequence_complete=complemento+list(sequence)+complemento
    return sequence_complete
    
'''Create groups of n amino acids. for instance
   1 from i to n
   2 from i+1 to n+1.   
   '''
def create_pairwise(iterable):
    iterables=[]
    iterables=tee(iterable,n)
    for i in range(1,n):
      for a in range(i):
        next(iterables[i],None)
    return zip(*iterables)

'''Fill arrays corresponding to each sliding window'''
def fill_matrix(tupla,matriz):
    init1=0
    init2=1
    x=tupla[init1]
    y=tupla[init2]
    for i in range(0,int(len(tupla)/2)):
        if matriz[x][y]==0:
            matriz[x][y]=1
            init1+=2
            init2+=2
        else:
            matriz[x][y]+=1
            init1+=2
            init2+=2
        if init2 <=len(tupla):
            x=tupla[init1]
            y=tupla[init2]
    return matriz

''''''
def generate_matrix(ventana,matriz,paso):    
    lista=[]
    for j in range(0,len(ventana)-1):
        lista.append(ventana[j])
        flag=element_exist(lista,j)
        if flag:
            continue
        else:
            if j < len(ventana)-paso: 
                tupla=recorrer_ventana(ventana,j,paso)
                matriz=fill_matrix(tupla,matriz)            
    return  matriz

''''''
def create_multiple_arrays(ventana):                
    matrices=[]
    paso=7
    for i in range(1,paso+1):  
        matriz=create matrix() 
        matrizfinal=generate_matrix(ventana,matriz,i)
        matrices.append(matrizfinal)
        matriz=[]      
    return matrices
''''''
def get_iterator_combinations(sequence_original):
    windows=create_pairwise(sequence_original)
    a=combinations(windows,2)
    return a
''''''
def get_distance_mat(nameFile,u,Url):
    dist_matrix=create_dist_matrix(nameFile,u,Url)    
    return dist_matrix
''''''
def create_dist_matrix(pdb_code,u,Url):
    parser=PDBParser()
    structure = parser.get_structure(pdb_code, Url)
    model = structure[0]
    dist_matrix = calc_dist_matrix (model ["A"], model ["A"],u)
    return dist_matrix
''''''
def calc_dist_matrix(chain_one, chain_two,u) :

    """Returns a matrix of C-alpha distances between two chains"""
    answer = np.zeros((u, u), np.float)
    for row, residue_one in enumerate(chain_one) :
        if(row==u):
            break
        for col, residue_two in enumerate(chain_two) :
            valor=calc_residue_dist(residue_one, residue_two)            
            if(col==u):
                break
            answer[row, col] = valor
    return answer

dicContactos= defaultdict( list )


def calc_residue_dist(residue_one, residue_two) :
    """Returns the C-alpha distance between two residues"""
    try:
        diff_vector = residue_one["CA"].coord -residue_two["CA"].coord
        distance=0
        distance=np.sqrt(np.sum(diff_vector*diff_vector))
        replace=np.nan_to_num(distance,nan=-1)

        return replace
    except:
        return -1


def elegir_Random(datos, pesos):
    r = random.random()
    for i, p in enumerate(pesos):
        if p > r:
            break
    return datos[i]

matrices=[]

def get_secuencia(PDBFile):
   with open(PDBFile, 'r') as pdb_file:
        for record in SeqIO.parse(pdb_file, 'pdb-atom'):
            pdb_file.close()
   return record.seq

def _float_feature(value):
  """Returns a float_list from a float / double."""
  return tf.train.Feature(float_list=tf.train.FloatList(value=value))



def serialize_example(matricesVa, matricesVr, distancia, propertiesVa,propertiesVr,pssm,clase):
  """
  Creates a tf.train.Example message ready to be written to a file.
  """
  # Create a dictionary mapping the feature name to the tf.train.Example-compatible
  feature = {
      'matricesVa': _float_feature(matricesVa),
      'matricesVr': _float_feature(matricesVr),
      'distancia': _float_feature([distancia]),
      'propertiesVa': _float_feature(propertiesVa),
      'propertiesVr': _float_feature(propertiesVr),
      'pssm': _float_feature(pssm),
      'clase':_float_feature(clase),     
  }
  example_proto = tf.train.Example(features=tf.train.Features(feature=feature))
  return example_proto.SerializeToString()

def getCompositionR(st):
    vaStrvR=''.join(map(str, st))
#     %R ar<-'$vaStrvR'
    resul = %R vhseScales(ar)    
    return list(resul[0])

def getPssm(SeqA,SeqB):
  DNA_motif = [Seq(SeqA),Seq(SeqB)]
  motif = motifs.create(DNA_motif,alphabet="DERKNHQSTAGVPLFYIMWC-X") 

  motif.degenerate_consensus
  W = motif.pssm
  matriz=[]
  for i in W:
    l=[]
    for j in W[i]:    
      if(str(j)=='-inf'):
        l.append(-1.0)
      else:
        l.append(j)
    matriz.append(l)
  matriz=np.array(matriz).flatten()

  
  return matriz

def dist_encode(value):
    table={
        0:[1,0,0,0],
        1:[0,1,0,0],
        2:[0,0,1,0],
        3:[0,0,0,1],
        }
    if(value >=0 and value<8):
        return table[0]
    elif(value >=8 and value<10):
        return table[1]
    elif(value >=10 and value<15):
        return table[2]
    else:
        return table[3]

def controlRecords(conteoCeros,conteoUnos,peso):    
    if(conteoCeros>conteoUnos and (conteoCeros-conteoUnos)>50):
      peso = [rechazo+0.01,ingreso-0.01]
    else:
      if(conteoUnos>conteoCeros and (conteoUnos-conteoCeros)>50):
        peso = [rechazo-0.02,ingreso+0.02]  
    return peso


def countByClass(clase_1,clase_2,clase_3,clase_4,clase):
    
    if(clase[0]==1):
      clase_1 =clase_1 + 1

    if(clase[1]==1):
      clase_2 =clase_2 + 1

    if(clase[2]==1):
      clase_3 = clase_3 + 1

    if(clase[3]==1):
      clase_4 =clase_2 + 1
    
    return clase_1,clase_2,clase_3,clase_4


def createFeatures(vAStr,vBStr,vA,vB):

    propertiesVa=getCompositionR(vAStr) #       
    propertiesVr=getCompositionR(vBStr)#

    pssm=getPssm(vAStr,vBStr)#

    matricesA=create_multiple_arrays(vA)#    
    matricesA= np.array(matricesA)    
    matricesA=np.stack(matricesA, axis=2).flatten()
    
    matricesB=create_multiple_arrays(vB)
    matricesB = np.array(matricesB)              
    matricesB=np.stack(matricesB, axis=2).flatten() 

    return propertiesVa,propertiesVr,pssm,matricesA,matricesB

import tempfile
import time

def main():  
  '''Read protein sequence'''
  datos = [0,1]
  peso = [rechazo,ingreso]

  clase_1=0
  clase_2=0
  clase_3=0
  clase_4=0

  conteoCeros=0
  conteoUnos=0

  '''Loading of Protein IDs downloaded from the PDB database'''
  pdblist=get_idProteins("/content/drive/MyDrive/Tesis/CURRENTPDB.txt")

  '''File where the data set will be saved.'''
  path="/content/drive/MyDrive/Tesis/borrar.dat"
  
  '''Write the records to a file.'''
  with tf.io.TFRecordWriter(path) as file_writer:

    '''The ID list is traversed, in addition to specifying the amount of proteins to be processed'''
    for proteinID in pdblist[1:10]:

      '''A try catch is set to avoid any crash of some proteins that have an error in the file.''' 
      try:
        print("Id Protein: "+str(proteinID))
        PDBFile = "/content/drive/MyDrive/Tesis/PDB/pdb"+proteinID+".ent"

        '''Obtaining the sequence of a protein is specific'''
        sequence=get_sequence(PDBFile)
        matriz_size=len(sequence)

        print(sequence)
        print(matriz_size)

        '''Control the amount of amino acids that a protein can have, if the size of
           the sequence is less than 1000 it is processed.'''
        if matriz_size>1000:
          continue

        '''Method that adds special character "-" at the beginning and at the end of the sequence. 
          The amount depends on the size of the window.
          Example: 
          if n is window size, n=19
          So we apply mod to get the number of characters to add 9=(n // 2) where it must be an odd number n=2a-1.'''        
        modified_sequence=prepareSequence(sequence)
        
        '''Generate all possible window combinations for a non-repeat protein sequence'''
        combinations=get_iterator_combinations(modified_sequence)
        
        '''Get the distance matrix, which will be the basis for
           differentiate the 3 classes of contact and 1 of non-contact.'''
        distanceMat=get_distance_mat(proteinID,matriz_size,PDBFile)



        '''Starts the traversal of the protein sequence, where i represents the
           columns of a matrix and j the rows. The array that is generated is
           equal in length to the distanceMat array.'''
        for i in range(len(sequence)-1):
          for j in range(i+1,len(sequence)):
           
            '''The pairs that contain the sliding windows are traversed one by one'''
            '''WindowA = window slider
               WindowB = continuous sliding window'''               
            windowA,windowB=next(combinations) 

            # Obtener una posicion especifica de la matriz de distanacia (i,j)
            '''Get a specific position from the distance matrix (i,j)'''
            distanceAmino=distanceMat[i][j]            
            
            # Codifica las clases entre 1000,0100,0010 y 0001, dependiendo de la 
            # distancia entre aminoacidos
            '''Encode classes between 1000,0100,0010 and 0001,
               depending on the distance between amino acids.'''
            clase=[]
            clase=dist_encode(distanceAmino)
            
            # Controla la cantidad de contactos y no contactos que se aceptaran
            # para el dataset
            '''Controls the number of contacts and non-contacts that will be accepted for the dataset.'''
            peso=controlRecords(conteoCeros,conteoUnos,peso)

            # Permite dar prioridad mas a los contactos que a los no contactos
            '''Allows you to give more priority to contacts than to non-contacts.'''
            ra=random.random()
            numeroRd = elegir_Random(datos, peso)
            redondeado = round(ra, 3)
            if((clase[3]==0) or (clase[3]!=0  and numeroRd==1)):
              #Segundo filtro para excluir los no contactos
              '''Second filter to exclude non-contacts'''
              if (clase[3]!=0 or redondeado<0.3):
                
                # Calculation of distance between pair of sliding windows
                '''Calculation of distance between pair of sliding windows'''
                distancia=j-i #1

                '''Make a copy of each window'''           
                SVA=windowA[:]
                SVB=windowB[:]      
                
                # Se codifican las ventanas deslizantes: cada aminoacido de la secuencia
                # se asocia a un identificador numérico
                '''Sliding windows are encoded: each amino acid in the sequence
                  is associated with a numerical identifier'''
                vA=get_encoding(windowA)
                vB=get_encoding(windowB)


                
                
                #Contador para identificar cuantos registros hay por clase, es informativo
                '''Counter to identify how many records there are per class, it is informative'''
                clase_1,clase_2,clase_3,clase_4=countByClass(clase_1,clase_2,clase_3,clase_4,clase)
                

                vAStr=''.join(map(str, SVA))
                vBStr=''.join(map(str, SVB))

                '''Construction of features'''
                propertiesVa,propertiesVr,pssm,matricesVa,matricesVr=createFeatures(vAStr,vBStr,vA,vB)
                
                # Esribir caracteristicas que conforman el dataset en un archivo
                '''Write features that make up the dataset to a file'''
                se=serialize_example(matricesVa, matricesVr, distancia, propertiesVa,propertiesVr,pssm,clase)
                file_writer.write(se) 
      except:
        print("PROTEIN ERROR")
  
  print("Clase_1: "+str(clase_1))
  print("Clase_2: "+str(clase_2))
  print("Clase_3: "+str(clase_3))
  print("Clase_4: "+str(clase_4))
    




if __name__ == '__main__':
    main()