# -*- coding: utf-8 -*-
"""
    Copyright (C) 2022  CRBM - CNRS

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program. If not, see <https://www.gnu.org/licenses/>
testContactMap.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QIfZS1oS3bGWciHvWe6NRyrYKKfpg1EC
"""

from google.colab import drive
drive.mount('/content/drive')

!pip install tensorflow==2.9
!apt install --allow-change-held-packages libcudnn8=8.1.0.77-1+cuda11.2

# Commented out IPython magic to ensure Python compatibility.
!pip install biopython
# %load_ext rpy2.ipython
# %R install.packages("Peptides", dependencies=TRUE)
# %R library(Peptides)

# Commented out IPython magic to ensure Python compatibility.
def getCompositionR(st):
  vaStrvR=''.join(map(str, st))
#   %R ar<-'$vaStrvR'
  resul = %R vhseScales(ar)
  return list(resul[0])

import tensorflow as tf
import numpy as np
from tensorflow import keras
import more_itertools
from Bio import SeqIO
from Bio.PDB.PDBParser import PDBParser
from collections import defaultdict
from itertools import *
from itertools import combinations
import pickle
from more_itertools import windowed
from itertools import *
import random
import time
from Bio import motifs 
from Bio.Seq import Seq


n=19
numAdd=(n // 2)


def elegir_Random(datos, pesos):
    r = random.random()
    for i, p in enumerate(pesos):
        if p > r:
            break
    return datos[i]

def pairwise(iterable):
    l=[]
    l=tee(iterable,n)
    for i in range(1,n):
      for a in range(i):
        next(l[i],None)
    return zip(*l)

def create_dist_matrix(pdb_code,u,Url):
    parser=PDBParser()
    structure = parser.get_structure(pdb_code, Url)
    model = structure[0]
    dist_matrix = calc_dist_matrix (model ["A"], model ["A"],u)
    return dist_matrix

def calc_dist_matrix(chain_one, chain_two,u) :

   #retorna la matriz de distancias
    answer = np.zeros((u, u), np.float)
    for row, residue_one in enumerate(chain_one) :
        if(row==u):
            break
        for col, residue_two in enumerate(chain_two) :
            valor=calc_residue_dist(residue_one, residue_two)
            if(col==u):
                break
            answer[row, col] = valor
    return answer

def calc_residue_dist(residue_one, residue_two) :

  try:
      diff_vector = residue_one["CA"].coord -residue_two["CA"].coord
      distance=0
      distance=np.sqrt(np.sum(diff_vector*diff_vector))
      replace=np.nan_to_num(distance,nan=-1)

      return replace
  except:
      return -1

def create_contact_map(distance_matrix) :
    distance_matrix[distance_matrix>8]=0.0
    distance_matrix[distance_matrix>0]=1.0
    return distance_matrix

def contact_map(nameFile,u,Url):
        dist_matrix=create_dist_matrix(nameFile,u,Url)
        contact_map=create_contact_map(dist_matrix)

        return contact_map

'''Crea matriz nxn de ceros'''
def crear_matriz():
    array=np.zeros((21,21),dtype=float)
    return array

def element_exist(list,index):

    if list.count(list[index])>=2:
        flag=True
    else:
        flag=False
    return flag

'''recorrer-secuencia distancia n'''
def recorrer_ventana(ventana,j,paso):
    var=ventana[j]

    tupla=[]
    for i in range(0,len(ventana)-paso):
        if ventana[i]==var:
            tupla.append(ventana[i])
            tupla.append(ventana[i+paso])
    return tupla

def llenar_matriz(tupla,matriz):
    init1=0
    init2=1
    x=tupla[init1]
    y=tupla[init2]
  
    for i in range(0,int(len(tupla)/2)):
        if matriz[x][y]==0:
            matriz[x][y]=1
            init1+=2
            init2+=2
        else:
            matriz[x][y]+=1
            init1+=2
            init2+=2
        if init2 <=len(tupla):
            x=tupla[init1]
            y=tupla[init2]
 
    return matriz

def get_iterator(sequence_original):
    ventaneo=pairwise(sequence_original)
    a=combinations(ventaneo,2)
    return a

def prepararSecuencia(sequence):
    complemento=list("-"*numAdd)
    sequence_complete=complemento+list(sequence)+complemento
    return sequence_complete

'''Crear diccionario'''
def create_dictionary(aminoacids):
    dictionary=defaultdict(lambda: 20,zip(aminoacids,[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))
    return dictionary

aminoacids="DERKNHQSTAGVPLFYIMWC-"
diccionario=create_dictionary(aminoacids)

'''obtener coordenadas'''
def get_coordenadas(tupla):
    item=[]
    for i in range(0,len(tupla)):
        for j in range(0,len(tupla[0])):
            item.append(diccionario[tupla[i][j]])

    return item

def generar_matriz(ventana,matriz,paso):
    
    lista=[]
    for j in range(0,len(ventana)-1):
        lista.append(ventana[j])
        flag=element_exist(lista,j)
        if flag:
            continue
        else:
            if j < len(ventana)-paso: 
                tupla=recorrer_ventana(ventana,j,paso)
                matriz=llenar_matriz(tupla,matriz)
    return  matriz

def crear_matrices(ventana):
            
    matrices=[]
    paso=7
    for i in range(1,paso+1):  
        matriz=crear_matriz() 
        matrizfinal=generar_matriz(ventana,matriz,i)
        matrices.append(matrizfinal)
        matriz=[]      
    return matrices

def getPssm(SeqA,SeqB):

  DNA_motif = [Seq(SeqA),Seq(SeqB)]
  motif = motifs.create(DNA_motif,alphabet="DERKNHQSTAGVPLFYIMWC-X") 

  motif.degenerate_consensus
  W = motif.pssm
  matriz=[]
  for i in W:
    l=[]
    for j in W[i]:    
      if(str(j)=='-inf'):
        l.append(-1)
      else:
        l.append(j)
    matriz.append(l)

  matriz=np.array(matriz).flatten()
 
  return matriz   


listVA=[]
listVR=[]
listPi=[]
listPj=[]
listMa=[]
listMr=[]
listDis=[]
matrices=[] 
listScaleVA=[]
listScaleVR=[]


def processing(rna_model, datos):
    peso = [0.7,0.3]

    print("inicio")
    
        
    for num in range(0,500,1):
        
        protein=datos[num][b'name'].decode("utf-8")
        print("PROTEINA: "+str(protein))
        name=protein[:-1]
        model=protein[-1:]
        sequence=datos[num][b'sequence'].decode("utf-8")
        
        print('lenght',len(sequence))

        if len(sequence)>=0:

          print('Processing protein '+str(num)+':'+name) 
          outfile1=open('/content/drive/MyDrive/Tesis/contactmap-Model60/'+protein+'1'+'.cm','w')
          outfile2=open('/content/drive/MyDrive/Tesis/contactmap-Model60/'+protein+'2'+'.cm','w')
          outfile3=open('/content/drive/MyDrive/Tesis/contactmap-Model60/'+protein+'3'+'.cm','w')
          outfile1.write('#CMVIEW GRAPH FILE ver: 1.0\n')
          outfile1.write('#SEQUENCE: '+sequence+'\n')
          outfile1.write('#PDB: ' + protein+'\n')
          outfile1.write('#PDB CHAIN CODE:'+model+'\n')
          outfile1.write('#CHAIN:'+ model +'\n')
          outfile1.write('#MODEL: 1'+'\n')
          outfile1.write('#CT: Ca'+'\n')
          outfile2.write('#CMVIEW GRAPH FILE ver: 1.0\n')
          outfile2.write('#SEQUENCE: '+sequence+'\n')
          outfile2.write('#PDB: ' + protein+'\n')
          outfile2.write('#PDB CHAIN CODE:'+model+'\n')
          outfile2.write('#CHAIN:'+ model +'\n')
          outfile2.write('#MODEL: 1'+'\n')
          outfile2.write('#CT: Ca'+'\n')
          outfile3.write('#CMVIEW GRAPH FILE ver: 1.0\n')
          outfile3.write('#SEQUENCE: '+sequence+'\n')
          outfile3.write('#PDB: ' + protein+'\n')
          outfile3.write('#PDB CHAIN CODE:'+model+'\n')
          outfile3.write('#CHAIN:'+ model +'\n')
          outfile3.write('#MODEL: 1'+'\n')
          outfile3.write('#CT: Ca'+'\n')
          outfile1.write('#CUTOFF: 8.0'+'\n')
          outfile2.write('#CUTOFF: 10.0'+'\n')
          outfile3.write('#CUTOFF: 15.0'+'\n')
          
          prepareSequence=prepararSecuencia(sequence)
          comb=get_iterator(prepareSequence)
          length = sum(1 for ignore in comb)
          print("tama√±o comb: "+str(length))
          combinations=get_iterator(prepareSequence)
          num=0

          vAAux=[]
          contDist=0
          for i in range(len(sequence)-1):
            for j in range(i+1,len(sequence)):

              vA, vR=next(combinations)
              vaStrvA=''.join(map(str, vA))
              vaStrvR=''.join(map(str, vR))
              
              propertiesVa=getCompositionR(vaStrvA)
              propertiesVr=getCompositionR(vaStrvR)
              propertiesVa=np.array(propertiesVa).reshape(1,8)
              propertiesVr=np.array(propertiesVr).reshape(1,8)

              vA=get_coordenadas(vA)
              vR=get_coordenadas(vR)

              my_pssm=getPssm(vaStrvA,vaStrvR)

              matricesVa=crear_matrices(vA)
              matricesVa=np.array(matricesVa)
              matricesVa=np.stack(matricesVa, axis=2)
              matricesVa=matricesVa.reshape(1,21,21,7)           
              matricesVr=crear_matrices(vR)
              matricesVr=np.array(matricesVr)
              matricesVr=np.stack(matricesVr, axis=2)
              matricesVr=matricesVr.reshape(1,21,21,7)
              distance=j-i
              distance=np.array(distance).reshape(1,1)
              my_pssm=np.array(my_pssm).reshape(1,22,19,1)

              input =(matricesVa,matricesVr,distance,propertiesVa, propertiesVr,my_pssm)             

              output=rna_model(input)
              
              output=output[0].numpy()            
              value=max(output)
              idx=np.argmax(output)
             
              if idx==0:
                outfile1.write(str(i+1)+'\t'+str(j+1)+'\t'+ str(1) +'\n')
              if idx<=1:
                outfile2.write(str(i+1)+'\t'+str(j+1)+'\t'+ str(1) +'\n')
              if idx<=2:
                outfile3.write(str(i+1)+'\t'+str(j+1)+'\t'+ str(1) +'\n')
                
          outfile1.close()
          outfile2.close()  
          outfile3.close()      

print('load data')
infile = open('/content/drive/MyDrive/Tesis/pdb25-test-500.release.contactFeatures.pkl','rb')
datos = pickle.load(infile,encoding='bytes')
print("cargando modelo")
rna_model = tf.keras.models.load_model('/content/drive/MyDrive/Tesis/Model1000Protein-25-1N.h5')
print("processing")
processing(rna_model,datos)
